#!/usr/bin/env bash
_VERSION_='2016.02.23_testing' # based on 2016.02.23_unstable
_BRANCH_='testing' # used for update.
# Google Drive Public Folder Mass Downloader
# by NoUrEdDiN : noureddin95@gmail.com
# License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
#
#  Some documentations and help phrases are copied, as-is or with change, from GNU grep, GNU wget, and youtube-dl.
#

trash='t' # Trashing Behavior: 't' for trash (send them to a hidden folder in their parent folder)
          #+                   'r' for remove (remove them completely)

trashbin='TRASH' # a hidden folder created in every folder, to send the trashed files and folders to.
                 # It must be hidden; ie, its name must start with a dot; So, this dot is included in the code,
                 #+ to avoid any problem could happen if missed.
idlist='IDs' # a hidden file in each folder. It contains the ID and the name of its parent folder contents.

# $_MODE_:
#   null: normal, # output the pwd & the summary of downloaded file (if any)
#   1: quiet,     # do not output anything usual (output errors and warning only, if any)
#   2: verbose,   # output the pwd & everything about the files downloading processes
#   3: debug,     # output as much information as possible
#

for i in "$@"  # checking debug mode
do
  case "$i" in
  '-d'|'--debug')
    set -vx
    _MODE_=3
    echo "_VERSION_ is $_VERSION_" >/dev/null
    echo "_BRANCH_ is $_BRANCH_" >/dev/null
    for i in "$@";do echo "$i" >/dev/null;done
    ;;
  esac
done

## FUNCTIONS

trash() # remove files and folders that are no longer online from the local copy
{
  # $1 is the trashed file or folder
  case "$trash" in
  't')
    [ "$_MODE_" != "1" ] && outecho 'Trashing '$1
    mkdir -p ".$trashbin"
    mv -f "$1" ".$trashbin"
    ;;
  'r')
    [ "$_MODE_" != "1" ] && outecho 'Removing '$1
    rm -rf "$1"
    ;;
  esac
}

download()
{
  # $1 is $ID, $2 is $TITLE/$FILENAME
  u=; # for update files
  # Download Only files that end in .part, do not exist, or found but with a different size.
  if [ "$_OVERWRITE_" == "1" ]
  then
    size=$(wget -q "$1" --save-headers -O - | head -n 20 | grep Content-Length: | sed 's/[^0-9]*//g')
    [ "$size" == "" ] && size=$(stat -c %s "$2" 2>/dev/null) # Some files doesn't have size. We don't redownload them by default.
    if [ -e "$2" ] && [ "$(stat -c %s "$2" 2>/dev/null)" != "$size" ]
    then
      (_MODE_=1; trash "$2";)
      u=1
    fi
  fi
  if [ -f "$2.part" ] || [ ! -f "$2" ]
  then
    if [ "$_MODE_" == "1" ] # quiet
    then
      wget -q -c "$1" -O "$2.part" \
      $([[ "$_RATE_" == "" ]] || echo "--limit-rate=$_RATE_") \
      $([[ "$_WO_" == "" ]] || echo "$_WO_")
    elif [ "$_MODE_" == "2" ] || [ "$_MODE_" == "3" ] # verbose or debug
    then
      [ "$u" == 1 ] && { outupdate "$2"; echo; } || { outget "$2"; echo; }
      wget -c "$1" -O "$2.part" \
      $([[ "$_RATE_" == "" ]] || echo "--limit-rate=$_RATE_") \
      $([[ "$_WO_" == "" ]] || echo "$_WO_")
    else # neither quiet, nor verbose; i.e., normal
      [ "$u" == 1 ] && outupdate "$2" || outget "$2"
      wget -q -c "$1" -O "$2.part" \
      $([[ "$_RATE_" == "" ]] || echo "--limit-rate=$_RATE_") \
      $([[ "$_WO_" == "" ]] || echo "$_WO_") &&
      (
        if [ $(stat -c %s "$2.part") -le 4000 ] && grep -q '/uc?export=download' "$2.part" 
        then  outconfirm
        else  outdone '('$(a=`ls "$2.part" -hs`; echo ${a%% *})')'
        fi
      )
    fi && mv "$2"{.part,} # only executed if wget succeeds
  fi
}

title_escape()
{
  t="${1//'&amp;'/'&'}" # fix &
  t="${t//'/'/'-'}" # replace / with -
  t="${t//':'/'-'}" # replace : with -
  t="${t//'&#39;'/\'}" # replace &#39; with '
  t="${t//'&quot;'/\"}" # replace &quot; with "
  t="$(echo "$t" | sed 's/^[ \t]*//;s/[ \t]*$//')" # trim leading & trailing spaces - if found
  echo "$t"
}

title_reverse()
{
  # Reversing the title-escaping procedure, adapted to grep
  t="${1//'&'/'&amp;'}"
  t="${t//\'/'&#39;'}"
  t="${t//\"/'&quot;'}"
  t="${t//'['/'\['}"  # for grep
  t="${t//']'/'\]'}"  # for grep
  t="${t//'-'/'[-/:]'}"
  t="${t%.part}"
  t="${t%.pdf}\(.pdf\)\?" # we add an additional ".pdf" to Google Docs
  echo "$t"
}

chex() # Choose and Exclude
{
  if [ ${#_CHOOSE_[@]} -ne 0 ] &&  [ ${#_EXCLUDE_[@]} -ne 0 ]
  # if the user used CHOOSE and EXCLUDE at the same time
  then
    outwarn ' ERROR: ' 'Choose and Exclude are used at the same time.'
    exit 2
  fi
  
  if [ ${#_CHOOSE_[@]} -ne 0 ]
  # the user used CHOOSE
  then
    if ! for i in "${_CHOOSE_[@]}";do echo $i;done | grep -q ^"$1"$
    # $TITLE($1) is NOT in $_CHOOSE_
    then
      continue
    fi
  fi
  
  if [ ${#_EXCLUDE_[@]} -ne 0 ]
  # the user used EXCLUDE
  then
    if for i in "${_EXCLUDE_[@]}";do echo $i;done | grep -q ^"$1"$
    # $TITLE($1) is in $_EXCLUDE_
    then 
      continue
    fi
  fi
}

outecho() # echo the given string, surrounded by bold '*'s
{
  if [ "$_NO_COLORS_" == "1" ]
  then  echo " * $@ *";
  else  tput bold;echo -n ' * ';tput sgr0; echo -n "$@"; tput bold;echo ' *';tput sgr0
  fi
}

outget() # outecho for "Getting"-messages
{
  if [ "$_NO_COLORS_" == "1" ]
  then  echo -n " * Getting $@ * ";
  else  tput bold;echo -n ' * ';tput sgr0; echo -n "Getting $@"; tput bold;echo -n ' * ';tput sgr0
  fi
}

outupdate() # outecho for "Updating"-messages
{
  if [ "$_NO_COLORS_" == "1" ]
  then  echo -n " * Updating $@ * ";
  else  tput bold;echo -n ' * ';tput sgr0; echo -n "Updating $@"; tput bold;echo -n ' * ';tput sgr0
  fi
}

outdone() # outecho for "Done"-messages
{
  if [ "$_NO_COLORS_" == "1" ]
  then  echo "Done $@ *";
  else  echo -n "Done $@"; tput bold;echo ' *';tput sgr0
  fi
}

outconfirm() # outecho for "CONFIRM"-messages
{
  if [ "$_NO_COLORS_" == "1" ]
  then  echo 'CONFIRMATION REQUIRED *';
  else  echo -ne '\e[1;31mCONFIRMATION REQUIRED\e[m'; tput bold;echo ' *';tput sgr0
  fi
}

outbold() # echo in bold
{
  if [ "$_NO_COLORS_" == "1" ]
  then  echo "$@";
  else  tput bold; echo "$@"; tput sgr0
  fi
}

outwarn() # output warnings to stderr, bold red for $1, then bold for $2
{
  if [ "$_NO_COLORS_" == "1" ]
  then
    >&2 echo "$1" "$2"
  else
    >&2 echo -ne '\e[1;31m'"$1"'\e[m'
    >&2 tput bold; >&2 echo "$2"; >&2 tput sgr0
  fi
}

help()
{
  echo "Usage: $(basename "${BASH_SOURCE[0]}") [OPTION]... URL...
Download from Google Drive an entire folder recursively,
with all it's files and sub-folders.
It can, also, download the big files that Google does not allow
download them without confirmation.
URL can be a folder URL or a file URL.
Example: $0 https://drive.google.com/folderview?id=0BXXXXXXXXXXX

General Options:
  -h,  --help            display this help text.
  -V,  --version         display version information.
  -L,  --license         display license information.
  -U,  --update          update to the latest version.
  -cu, --check-update    check if up-to-date or not.

Selection Options:
  -ch, --choose=NAME     choose a file or folder by its NAME,
                         and nothing else will be downloaded.
  -ex, --exclude=NAME    exclude a file or folder by its NAME,
                         and everything else will be downloaded.

Downloading Options:
  -l,  --limit=RATE      limit download rate (speed) to RATE.
  -ad, --auto-detect-dirs  download each directory url into
                         a directory of its name, not in
                         the current one.
  -cd, --directory=DIR   change to directory DIR; i.e., use it
                         as a place to download in, instead of
                         the current directory.
  -wo, --wget-option=OPT  if you want to provide specific Wget options.
  -o,  --overwrite       if a Drive file is updated, overwrite the local
                         one with the new copy
  -t,  --trash           trash the no-longer-online files and folders
  
Output Options:
  -q,  --quiet           suppress all normal output.
  -v,  --verbose         output more information than usual.
  -d,  --debug           output much debugging information.
  -nc, --no-colors       output in plain text.

Confirming Options:
  to get the big files that Google does not allow to download them
  directly without confirmation.

  -c,  --confirm[=NAME]  if no NAME is given, download all files
                         that need confirmation in the current
                         folder (recursively). If a NAME of a file
                         is given, then confirm and download this file.
  -cc, --confirm-check   only display the relative path of the files
                         that need confirmation in the current folder
                         (recursively).

Notice that both Choose and Exclude can be used many times in the same
time to choose or exclude many files or folders.
Notice also that you cannot use both at the same time.

Not using either '--quiet' or '--verbose' means the normal (default) mode.

Notice that short options cannot be compound, that means you
cannot use '-qc' as equivalent to '-q -c'; It will not be recognized.
Also, you must use the equal sign '=' with both short and long options,
if you assign them a value.
"
}

## END FUNCTIONS

# the absolute path of the script; because we'll call it again.
[ -z "${_SCRIPT_}" ] && export _SCRIPT_="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/$(basename "${BASH_SOURCE[0]}")"

# PRE MAIN _ READING THE ARGUMENTS
for i in "$@"
do
  case "$i" in
    *'file'*|*'folder'*)
      URLS=("${URLS[@]}" "${i//&*/}")
      ;;
    '--confirm'|'-c')
      # to get the big files that Google does not allow to download them directly without confirmation
      _CONFIRM_=1
      ;;
    '--confirm='*|'-c='*)
      # to confirm and download specific file(s)
      _CONFIRM_FILE_=("${_CONFIRM_FILE_[@]}" "${i#*=}")
      ;;
    '--confirm-check'|'-cc')
      # to just print a list of the big files that were not downloaded
      _CONFIRM_CHECK_=1
      ;;
    '--directory='*|'-cd='*)
      # Note that using this switch more that one time, will not cause an error; but only the last will affect.
      cd "${i#*=}"
      pwd
      ;;
    '--limit='*|'-l='*)
      [ -n "$_RATE_" ] && _RATE_WARN_=1 || export _RATE_="${i#*=}"
      ;;
    '--auto-detect-dirs'|'-ad')
      _AUTO_DETECT_DIRS_=1
      ;;
    '--trash'|'-t')
      export _TRASH_=1
      ;;
    '--overwrite'|'-o')
      export _OVERWRITE_=1
      ;;
    '--no-colors'|'-nc')
      export _NO_COLORS_=1
      ;;
    '--wget-option='*|'-wo='*)
      [ -n "$_WO_" ] && _WO_WARN_=1 || export _WO_="${i#*=}"
      ;;
    '--quiet'|'-q') # see $_MODE_ in the file header
      [ -n "$_MODE_" ] && _MODE_WARN_=1 || export _MODE_=1
      ;;
    '--verbose'|'-v')
      [ -n "$_MODE_" ] && _MODE_WARN_=1 || export _MODE_=2
      ;;
    '--mode='*)
      # It's supposed to be set only one time. Otherwise, the last one will be the only one to have an effect.
      # It's made to be used only by the script, but the user can use it also.
      export _MODE_=${i//--mode=/}
      ;;
    '--choose='*|'-ch='*)
      i=${i#*=}
      _CHOOSE_=("${_CHOOSE_[@]}" "${i%/}")
      ;;
    '--exclude='*|'-ex='*)
      i=${i#*=}
      _EXCLUDE_=("${_EXCLUDE_[@]}" "${i%/}")
      ;;
    '--help'|'-h')
      _HELP_=1
      ;;
    '--branch='*|'-b='*)
      _BRANCH_="${i#*=}"
      ;;
    '--update'|'-U')
      [ "$_MODE_" != "1" ] && echo -n 'Updating to '
      v=$(wget -q 'https://raw.githubusercontent.com/noureddin/gdrive-dl/master/gdrive-dl_'$_BRANCH_ -O - | head -n 2)
      v=${v%\'*}; v=${v#*\'}
      if [ -n "$v" ]
      then
        [ "$_MODE_" != "1" ] && echo "$v"
        ( wget -q 'https://raw.githubusercontent.com/noureddin/gdrive-dl/master/gdrive-dl_'$_BRANCH_ -O ${_SCRIPT_} & )
        exit
      else
        [ "$_MODE_" != "1" ] && echo 'N/A'
      fi
      ;;
    '--check-update'|'-cu')
      echo    'Your current version is  '"${_VERSION_}"
      echo -n 'The  latest  version is  '
      v=$(wget -q 'https://raw.githubusercontent.com/noureddin/gdrive-dl/master/gdrive-dl_'$_BRANCH_ -O - | head -n 2)
      v=${v%\'*}; v=${v#*\'}; [ -n "$v" ] && echo "$v" || echo 'N/A'
      ;;
    '--version'|'-V')
      echo $_VERSION_
      ;;
    '--license'|'-L')
      echo 'License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.'
      ;;
    '--debug'|'-d')
      ;;
    *)
      >&2 echo "'$i' is not recognized. Try '$(basename "${BASH_SOURCE[0]}") --help' for more information."
    ;;
  esac
done

[ "$_HELP_" == '1' ] && help # to print help only once

[ "$_RATE_WARN_" == '1' ] && outwarn ' WARNING: ' '`--limit` and/or `-l` are used multiple times at the same time; Using the first one.'

[ "$_MODE_WARN_" ] && outwarn ' WARNING: ' 'Quiet, Verbose, and/or Debug are used at the same time; Using Debug or the first provided one.'

[ "$_WO_WARN_" == '1' ] && outwarn ' WARNING: ' '`--wget-option` and/or `-wo` are used multiple times at the same time; Using the first one.'

# PRE MAIN _ END READING THE ARGUMENTS

## MAIN ()

for i in "${URLS[@]}"
do
  case "$i" in
  *file*)
    TITLE=$(wget -q "$i" -O -)
    TITLE=${TITLE#*<title>}; TITLE=${TITLE%% - Google Drive</title>*}
    TITLE=$(title_escape "$TITLE")
    ID=$(echo ${i//*0B/0B} | sed 's|/.*||') # TODO: Google Doc
    download "$ID" "$TITLE"
    ;;
  *folder*)
    FILE_0=$(wget -q "$i" -O -) # will NOT be modified
    FILE=$FILE_0 # will be modified
    
    # If auto_detect_dirs is chosen
    if [ "$_AUTO_DETECT_DIRS_" == "1" ]
    then
      TITLE=${FILE_0#*<title>}; TITLE=${TITLE%%</title>*}
      TITLE=$(title_escape "$TITLE")
      mkdir -p "$TITLE"
      cd "$TITLE"
      if [ "$_MODE_" != "1" ] # not quiet
      then
        outbold Now in "$TITLE/"
        NOWPATH="$TITLE/"
      fi
    fi
    
    # Getting the IDs and TITLEs
    until [ "$FILE" = "${FILE#*flip-entry-title\">}" ]
    do
      ID=${FILE#*id=\"entry-}; ID=${ID%%\"*}
      FILE=${FILE#*flip-entry-title\">}
      
      TITLE=${FILE%%</div*}
      TITLE=$(title_escape "$TITLE")
      
      OIDs=("${OIDs[@]}" "$ID")
      [ "${ID:0:1}" == '0' ] && # not Google Doc
        OTITLEs=("${OTITLEs[@]}" "$TITLE") ||
        OTITLEs=("${OTITLEs[@]}" "$TITLE.pdf")
      
      chex "$TITLE" # Choose and Exclude
      
      IDs=("${IDs[@]}" "$ID")
      [ "${ID:0:1}" == '0' ] && # not Google Doc
        TITLEs=("${TITLEs[@]}" "$TITLE") ||
        TITLEs=("${TITLEs[@]}" "$TITLE.pdf")
    done
    unset FILE
    
    touch ".$idlist"
    
    # First, check if a file or folder is renamed or removed.
    for index in ${!OIDs[@]}
    do
      title=$(grep "${OIDs[$index]}" ".$idlist"); title=${title#* }
      if [ "$title" != "${OTITLEs[$index]}" ] # renamed, or Google Doc (with an additional '.pdf'), or even not downloaded
      then
        if [ -e "$title" ] # renamed
        then
          mv "$title" "${OTITLEs[$index]}"
          [ "$_MODE_" != "1" ] && outecho "Renaming \"$title\" to \"${OTITLEs[$index]}\""
        fi
        sed -i "/^${OIDs[$index]} .*/d" ".$idlist"
        echo "${OIDs[$index]} ${OTITLEs[$index]}" >> ".$idlist"
      fi
    done
    
    # Trashing the no-longer-online files and folders before downloading.
    if [ "$_TRASH_" == "1" ]
    then
      ids=$(wc -l ".$idlist"); ids=${ids%% *};
      if [ $ids -gt ${#OIDs[@]} ]
      then
        cat ".$idlist" | while read x
        do
          case "${OIDs[*]}" in
          *"${x%% *}"*) continue;;
          *)
            trash "${x#* }"
            sed -i "/^${x%% *} .*/d" ".$idlist"
            ;;
          esac
        done
        for a in *  # http://mywiki.wooledge.org/BashPitfalls#for_i_in_.24.28ls_.2A.mp3.29
        do
          [ "$a" == '*' ] && break
          a="${a//'['/'\['}"
          a="${a//']'/'\]'}"
          grep "^[a-zA-Z0-9_]* $a$" ".$idlist" &>/dev/null
          [ $? -eq 0 ] && continue || [ $? -eq 1 ] && trash "$a"
          # if found; then  ...   else if not found; then ...
        done
      fi
    fi
    
    # Files First !
    for index in ${!IDs[@]}
    do
      case "$FILE_0" in # http://www.labnol.org/internet/direct-links-for-google-drive/28356/
      *'/docs.google.com/document/d/'${IDs[$index]}*) # Google Document
        download "https://docs.google.com/document/d/${IDs[$index]}/export?format=pdf" "${TITLEs[$index]}"
        IDs[$index]=; TITLEs[$index]=;
        ;;
      *'/docs.google.com/presentation/d/'${IDs[$index]}*) # Google Presentation
        download "https://docs.google.com/presentation/d/${IDs[$index]}/export/pdf" "${TITLEs[$index]}"
        IDs[$index]=; TITLEs[$index]=;
        ;;
      *'/docs.google.com/spreadsheets/d/'${IDs[$index]}*) # Google Spreadsheets
        download "https://docs.google.com/spreadsheets/d/${IDs[$index]}/export?format=pdf" "${TITLEs[$index]}"
        IDs[$index]=; TITLEs[$index]=;
        ;;
      *'/drive.google.com/uc?id\u003d'${IDs[$index]}*) # Regular File
        download "https://docs.google.com/uc?id=${IDs[$index]}&export=download" "${TITLEs[$index]}"
        IDs[$index]=; TITLEs[$index]=;
        ;;
      *'/drive.google.com/folderview?id\u003d'${IDs[$index]}*) # Folder; will be downloaded after the files
        ;;
      *) # Someting else! ### Remove it form the list
        IDs[$index]=; TITLEs[$index]=;
        ;;
      esac
    done
    
    unset FILE_0
    
    # Then, Folders
    for index in ${!IDs[@]}
    do
      [ -z "${IDs[$index]}" ] && continue
      [ ! -d "${TITLEs[$index]}" ] && mkdir -p "${TITLEs[$index]}" ; cd "${TITLEs[$index]}"
      if [ "$_MODE_" != "1" ] # not quiet
      then
        outbold Now in "$NOWPATH${TITLEs[$index]}/"
        NOWPATH="$NOWPATH${TITLEs[$index]}/" ${_SCRIPT_} https://drive.google.com/folderview?id=${IDs[$index]}
      else # quiet
        ${_SCRIPT_} https://drive.google.com/folderview?id=${IDs[$index]}
      fi
      cd ..
    done
    unset IDs TITLEs
  esac
done
## END MAIN ()


## POST MAIN _ CONFIRMATION
if [ "$_CONFIRM_CHECK_" == '1' ]
then
  grep -lr '/uc?export=download'
fi

if [ "$_CONFIRM_" == '1' ]
then
  grep -lr '/uc?export=download' | while read a
  do
    outbold Confirming "$a"
    URL=$(grep '/uc?export=download' "$a" | sed 's|.*uc?export=download|uc?export=download|' | sed 's|\".*||')
    perl "${_SCRIPT_%/*}/gdown.pl" 'https://drive.google.com/'"${URL//'&amp;'/'&'}" "$a"
  done
fi

if [ ${#_CONFIRM_FILE_[@]} -ne 0 ]                   
then
  for a in "${_CONFIRM_FILE_[@]}"
  do
    outbold Confirming "$a"
    URL=$(grep '/uc?export=download' "$a" | sed 's|.*uc?export=download|uc?export=download|' | sed 's|\".*||')
    perl "${_SCRIPT_%/*}/gdown.pl" 'https://drive.google.com/'"${URL//'&amp;'/'&'}" "$a"
  done
fi

## POST MAIN _ END CONFIRMATION
